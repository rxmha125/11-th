'use server';
/**
 * @fileOverview Generates an image for a memory.
 *
 * - generateMemoryImage - A function that generates an image based on a prompt.
 * - GenerateMemoryImageInput - The input type for the generateMemoryImage function.
 * - GenerateMemoryImageOutput - The return type for the generateMemoryImage function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
// Saving to DB will be handled by the calling component (MemoryTimelineCarousel) using image-service.ts
// import { saveImageForMemory } from '@/services/image-service'; 

const GenerateMemoryImageInputSchema = z.object({
  promptText: z.string().describe('A textual prompt to guide image generation, based on a memory.'),
  memoryId: z.string().optional().describe('An optional ID for the memory this image is associated with.'),
});
export type GenerateMemoryImageInput = z.infer<typeof GenerateMemoryImageInputSchema>;

const GenerateMemoryImageOutputSchema = z.object({
  imageDataUri: z.string().describe("The generated image as a data URI. Expected format: 'data:image/png;base64,<encoded_data>'."),
});
export type GenerateMemoryImageOutput = z.infer<typeof GenerateMemoryImageOutputSchema>;

export async function generateMemoryImage(input: GenerateMemoryImageInput): Promise<GenerateMemoryImageOutput> {
  return generateMemoryImageFlow(input);
}

// This is the flow that will be called by the client.
const generateMemoryImageFlow = ai.defineFlow(
  {
    name: 'generateMemoryImageFlow',
    inputSchema: GenerateMemoryImageInputSchema,
    outputSchema: GenerateMemoryImageOutputSchema,
  },
  async (input) => {
    const {media} = await ai.generate({
      model: 'googleai/gemini-2.0-flash-exp',
      prompt: `Generate a vibrant and romantic image depicting: ${input.promptText}. Focus on a dreamy, ethereal, and artistic style. The image should be suitable for a cherished memory. Avoid text in the image.`,
      config: {
        responseModalities: ['TEXT', 'IMAGE'],
         safetySettings: [
          { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_ONLY_HIGH' },
          { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' },
          { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_MEDIUM_AND_ABOVE' },
          { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_LOW_AND_ABOVE' },
        ],
      },
    });

    if (!media || !media.url) {
      throw new Error('Image generation failed or returned no media URL.');
    }
    
    const imageDataUri = media.url;
    // The calling component (MemoryTimelineCarousel) will handle saving to DB
    // using the image-service.ts
    // if (input.memoryId) {
    //   console.log(`Image for memory ${input.memoryId} generated by flow. Saving will be handled by the component.`);
    // }

    return {imageDataUri: media.url};
  }
);
